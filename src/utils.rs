// utils.rs
//
// Copyright (c) 2024 Max Rodriguez
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// SPDX-License-Identifier: GPL-3.0-or-later

//! Utility functions used by Album, such as thumbnail image generation.

use crate::config::APP_NAME;
use adw::glib::{g_debug, g_warning};
use async_process::{Command, Output};
use libadwaita as adw;
use std::fs::File;
use std::io;
use std::path::{Path, PathBuf};

/// Can be read by other modules in Album to display to
/// the user what binary needs to be installed to use Album.
pub static FFMPEG_BINARY: &str = "ffmpeg";

/// Returns a string path to a JPEG image generated by ffmpeg
/// as a cropped square thumbnail for an image or a video.
pub async fn generate_thumbnail_image(file_str_path: &str) -> io::Result<String> {
    let file_path: PathBuf = PathBuf::from(file_str_path);

    let file_name: &str = file_path
        .file_name()
        .expect("Failed to get file name.")
        .to_str()
        .unwrap();

    // TODO: If running within a Flapak sandboxed environment,
    // we can just store the cached jpeg files in $XDG_CACHE_HOME.
    // FIXME: Do not store by file name, but by fingerprint hash.
    let absolute_out_path: String = format!(
        "{}/{}/{}/{}-thumbnail.jpeg",
        match std::env::var("XDG_CACHE_HOME") {
            Ok(value) => value,
            Err(e) => {
                match e {
                    std::env::VarError::NotPresent => {
                        // If $XDG_CACHE_HOME is either not set or empty,
                        // a default equal to $HOME/.cache should be used.
                        // https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html#variables
                        format!("{}/.cache", std::env::var("HOME").unwrap())
                    }
                    _ => panic!("Unexpected std::env::VarError type received."),
                }
            }
        },
        APP_NAME,
        "thumbnails",
        file_name
    );

    // Check if we have the thumbnail already cached, if so, return its path.
    match File::open(Path::new(&absolute_out_path)) {
        Ok(_) => {
            return Ok(absolute_out_path);
        }
        Err(e) => match e.kind() {
            io::ErrorKind::NotFound => g_debug!(
                "Utils",
                "'{}' not found in app cache. Generating new thumbnail.",
                absolute_out_path,
            ),
            _ => todo!(), // TODO: Extend error handling for cache check
        },
    }

    let file_extension: &str = file_path
        .extension()
        .expect("Was given file path with no file extension!")
        .to_str()
        .unwrap();

    let extra_arguments: &[&str] = match file_extension.to_lowercase().as_str() {
        "png" | "jpg" | "jpeg" | "webp" | "heic" | "heif" => {
            &["-vf", "crop='min(iw,ih):min(iw,ih)',scale=100:100"]
        }
        "mp4" | "webm" | "mkv" | "mov" | "avi" | "gif" => {
            &[
                "-vf",
                "thumbnail,crop='if(gt(iw,ih),min(iw,ih)/2*2,min(iw,ih))':'if(gt(iw,ih),min(iw,ih),min(iw,ih)/2)*2',scale=100:100",
                "-frames:v",
                "1",
            ]
        }
        _ => {
            g_warning!(
                "Utils",
                "'{}': unsupported file format, or an unrecognized extension.",
                file_extension
            );
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Invalid file format.",
            ));
        }
    };
    let ffmpeg_output: Result<Output, io::Error> = Command::new(FFMPEG_BINARY)
        .arg("-i")
        .arg(file_path)
        .args(extra_arguments)
        .arg(&absolute_out_path)
        .output()
        .await;

    // An error should **never** occur here, since we check the existence
    // of the ffmpeg binary installation at the start of the library load.
    match ffmpeg_output {
        Err(e) => panic!("Failed to execute ffmpeg binary!\n\n{}", e),
        Ok(_) => Ok(absolute_out_path),
    }
}
